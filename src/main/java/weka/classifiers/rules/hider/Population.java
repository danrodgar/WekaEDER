/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    Population.java
 *    Copyright (C) 2011 Marta Hernando, Daniel Rodriguez. Universidad de Alcala
 *
 */
package weka.classifiers.rules.hider;

import java.io.*;
import java.util.*;
import weka.core.*;
import weka.classifiers.rules.hider.evaluation.*;
import weka.classifiers.rules.hider.gene.*;

/**
 * Represents a population of rules.
 * @author Marta
 *
 */
public class Population implements Serializable {

	private static final long serialVersionUID = 1L;
	private HIDER_Rule[] HIDER_RulesList; 	// Stores a list of <code>HIDER_Rule</code> objects.
	private int m_NumIndividuals; 			// Maximum size of the population
	private double m_Target_class;			// Value of class was selected.
	private double[] m_PopulationFitness;	// Value of fitness.
	private Instances dataSetInstances;

	public Population(int numIndividuals, double target_class, Instances dataSetInstances) throws Exception {

		this.dataSetInstances=dataSetInstances;
		HIDER_RulesList = new HIDER_Rule[numIndividuals];
		
		for (int i=0;i<HIDER_RulesList.length;i++)
		{
			HIDER_RulesList[i]= new HIDER_Rule(target_class);
			HIDER_RulesList[i].grow(dataSetInstances);
		}
				
		m_NumIndividuals = numIndividuals;
		m_Target_class = target_class;
		m_PopulationFitness = new double[m_NumIndividuals];
	}

	/**
	 * Inits the population according to a target class.
	 * 
	 * @param target_class Target class to build the rules.
	 * @throws Exception 
	 */
	public void initPopulation(double target_class, ArrayList<Instance> m_Data,
			Random m_RandomGenerator,
			HIDER_Rule ruleMaxMin) throws Exception {
		
		int q = 0;
		double l, u,range,max,min;
		Instance instance;
		int m_NumAttributes = dataSetInstances.numAttributes();
		int m_ClassIndex = dataSetInstances.classIndex();

		for (int j = 0; j < m_NumIndividuals; j++) 
		{
			//To select an instance corresponding to the value of the selected class
			do {
				q = m_RandomGenerator.nextInt(m_Data.size());
				instance = m_Data.get(q);
			} while (instance.classValue() != (target_class));

			HIDER_RulesList[j] = new HIDER_Rule(instance.classValue());
			HIDER_RulesList[j].grow(dataSetInstances);
			
			for (int a = 0; a < m_NumAttributes; a++) {
				if (a != m_ClassIndex) {					
					if (HIDER_RulesList[j].getGene(a).isNumeric()) 
					{
						max=((Continuous) ruleMaxMin.getGene(a)).getUpperLimit();
						min=((Continuous) ruleMaxMin.getGene(a)).getLowerLimit();
						range=max - min;
						
						l = instance.value(a)- range/ (1000.0f) * m_RandomGenerator.nextFloat();
						
						if (l < min) {
							l = min;
						}

						u = instance.value(a)+ range/ (1.0f) * m_RandomGenerator.nextFloat();
											
						if (u > max) {
							u = max;
						}

						if (l < u) {
							((Continuous) HIDER_RulesList[j].getGene(a)).setLowerLimit(l);
							((Continuous) HIDER_RulesList[j].getGene(a)).setUpperLimit(u);
						} else {
							((Continuous) HIDER_RulesList[j].getGene(a)).setLowerLimit(u);
							((Continuous) HIDER_RulesList[j].getGene(a)).setUpperLimit(l);
						}
					} else if (HIDER_RulesList[j].getGene(a).isNominal()) {
						/*The same attributes that are generated by the aleatory instance are placed 
						and the other bits are mutated with certain probability*/
						((Discrete) HIDER_RulesList[j].getGene(a)).setNominalValue(instance.stringValue(a));
					}
				}																							
			}
		}
	}

	/**
	 * Calculates the fitness value of the current population.
	 */
	public double[] calculatePopulationFitness(ArrayList<Instance> m_Data,Fitness fit) {
		
		double suma, a;
		suma = 0.0;	
		for (int i = 0; i < m_NumIndividuals; i++) {
						
			//Strategy Pattern			
			Context ctx= new Context(fit,m_Data,m_Target_class);
			ctx.setStrategy(fit);		
			a = ctx.executeStrategy(HIDER_RulesList[i]);			
		
			if (a != -1.0) {				
				m_PopulationFitness[i] = 1.0 / (1.0 + a);
			} else {
				m_PopulationFitness[i] = 0.0;
			}
			suma += m_PopulationFitness[i];
		}

		for (int i = 0; i < m_NumIndividuals; i++) {
			m_PopulationFitness[i] /= suma;
			HIDER_RulesList[i].setFitness(m_PopulationFitness[i]);
		}

		return m_PopulationFitness;
	}


	/**
	 * Returns the index in the current population that indicates the best individual (rule).
	 * 
	 * @return Returns the index in the current population that indicates the
	 *         best individual (rule).
	 */
	public int getBestIndividual() {	
		
		return Utils.maxIndex(m_PopulationFitness);
	}

	/**
	 * Returns an individual of the population.
	 * @param index
	 * @param rule
	 */
	public void add(int index, HIDER_Rule rule) {
		HIDER_RulesList[index] = rule;
	}

	/**
	 * Sets an individual of the population.
	 * @param i
	 * @return HIDER_Rule
	 */
	public HIDER_Rule get(int i) {
		return HIDER_RulesList[i];
	}

}// Population